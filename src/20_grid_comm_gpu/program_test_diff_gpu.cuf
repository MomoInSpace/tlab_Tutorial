program comm_test
    use mpi_f08
    use TLAB_CONSTANTS
    use TLAB_ARRAYS 
    use TLAB_POINTERS_3D
    !use grid_handler
    use grid_handler_gpu
    use grid_comm_module
    use grid_comm_gpu_module
    use grid_debug
    use grid_ops
    implicit none 

    ! Parameters================================================================
    ! Input Grid Data
    INTEGER:: i, j, k, m, n, mi,ni
    character(len = 100):: fmt
    CHARACTER(len = 32):: arg

    integer                     :: world_size, my_rank
    type(Grid3D_Comm_gpu)   :: grid_comm_handler
    type(Grid3D_gpu), target    :: grid_handler_A, grid_handler_B, grid_handler_tmp, grid_handler_C, grid_handler_D
    type(Complete_grid_debugger):: testgrid_handler
    integer, dimension(3)       :: state_xyz  = [2, 1, 3], &
                                   ! Pertubation of [1, 2, 3]. 
                                   ! Describes the orientation of our array/grid. 
                                   block_xyz_dims, &
                                   ! Describes the size of the smallest grid_unit.
                                   block_multiplication_xyz_state = [1, 1, 0], &
                                   ! The block_xyz_dims get multiplied by the 
                                   ! threads as indicated by this state.
                                   ! Depending on the communication algorithm used, 
                                   ! the programm needs different states!
                                   subgrid_xyz_dims, &
                                   ! The size of the subgrid for each thread as 
                                   ! indicated by block_multiplication_xyz_state
                                   dims
    integer                     :: column_upper_limit
    integer, dimension(2)       :: task_state, rank_coords

    ! Error Integer
    INTEGER, dimension(100)     :: ierr  = 0

    integer                     :: send_num, overhead_factor
    logical                     :: pinnedFlag
    procedure(Ifunc), pointer :: func

    ! Body======================================================================
    ! Initialisation------------------------------------------------------------

    ! MPI Initialisation
    call MPI_Init()
    call MPI_Comm_rank(MPI_COMM_WORLD, my_rank)
    call MPI_Comm_size(MPI_COMM_WORLD, world_size)

     ! Read Input Parameters from Terminal---------------------------------------
     if (my_rank == 0) then
        do i = 1, COMMAND_ARGUMENT_COUNT()  ! Should be 3
            ! Get Arguments:
            call getarg(i, arg)
            READ(arg, '(I10)') block_xyz_dims(i)
            end do
     end if

    ! Define Complete Grid------------------------------------------------------
    ! Broadcast Input Parameters and use pointers for better readability
    call MPI_BCAST(block_xyz_dims, 3, MPI_INTEGER, 0, MPI_COMM_WORLD)
    column_upper_limit = block_xyz_dims(2)

    !Init grid_comm_handler-----------------------------------------------------
    ! Four possible states: [0, 1, 2, 12].
    grid_comm_handler = Grid3D_Comm_gpu(world_size, &
            block_xyz_dims, &
            block_multiplication_xyz_state, &
            column_upper_limit)
    subgrid_xyz_dims = grid_comm_handler%subgrid_xyz_dims  

    ! Init grid_handler derived types-------------------------------------------
    overhead_factor = 3
    grid_handler_A = Grid3D_gpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)
    grid_handler_B = Grid3D_gpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)
    grid_handler_C = Grid3D_gpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)
    grid_handler_D = Grid3D_gpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)
    grid_handler_tmp = Grid3D_gpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)

    allocate(x(grid_handler_A%total_space, 5), stat = ierr(1), pinned = pinnedFlag)
    if (ierr(1) /= 0) print *, "q(1, grid_handler%total_space), : Allocation request denied"

    allocate(x_d(grid_handler_A%total_space, 5), stat = ierr(1))
    if (ierr(1) /= 0) print *, "q(1, grid_handler%total_space), : Allocation request denied"

    call grid_handler_A%set_pointer_1D(x_d(:,1),x(:,1))
    call grid_handler_B%set_pointer_1D(x_d(:,2),x(:,2))
    call grid_handler_C%set_pointer_1D(x_d(:,3),x(:,3))
    call grid_handler_D%set_pointer_1D(x_d(:,4),x(:,4))
    call grid_handler_tmp%set_pointer_1D(x_d(:,5), x(:,5))

    ! Example: For later use
    !call grid_handler_A%get_pointer_3D(u)


    ! Set Values For visualization----------------------------------------------
    dims = grid_handler_A%get_dims()
    rank_coords = grid_comm_handler%MPI_Cart_Coords
    mi = rank_coords(1)
    ni = rank_coords(2)
    rank_coords = grid_comm_handler%MPI_Cart_Dims
    m = rank_coords(1)
    n = rank_coords(2)
    func => grid_func

    ! Check gather ------------------------------------------------------------
    ! Create subgrid
    call grid_handler_A%get_pointer_3D(u_d, u)
    func => grid_func
    u = 0
    call fill_subgrid(u,grid_handler_A%get_dims(), func,grid_comm_handler)
    ! Comm Supergrid
    call debug_values(grid_handler_A)
    call testgrid_handler%visualize_grid(my_rank, .false.)
    u => testgrid_handler%grid_pointer_3d

    ! Generate Theory Supergrid
    call testgrid_handler%get_dims(dims)
    call create_supergrid(dims, func) ! Create Supergrid Only has to be called once
    call get_supergrid(v,dims)


    call check_diff(u,v,dims, "Check Gather")

    ! Check Local Diff ---------------------------------------------------------
    call grid_handler_B%get_pointer_3D(v_d, v)
    v = 0 
    func => grid_func_dy
    call fill_subgrid(v, grid_handler_B%get_dims(), func,grid_comm_handler)

    call grid_handler_A%get_pointer_3D(u_d, u)
    u = 0
    func => grid_func
    call fill_subgrid(u, grid_handler_A%get_dims(), func,grid_comm_handler)

    call grid_handler_C%get_pointer_3D(w_d, w)
    w = 0
    x_d = x
    call grid_handler_A%diff_central1(w_d)
    x = x_d

    dims = grid_handler_A%get_dims()
    call check_diff(v,w,dims, "Local Diff")

    !Check Gather+Diff ---------------------------------------------------------
    call grid_handler_A%get_pointer_3D(u_d, u)
    u = 0
    func => grid_func
    call fill_subgrid(u, grid_handler_A%get_dims(), func,grid_comm_handler)
    grid_handler_B%grid_space_sync = 99
    grid_handler_C%grid_space_sync= 0
    grid_handler_D%grid_space_sync= 0


    x_d = x
    ! Visualize Complete Grid---------------------------------------------------
    !call debug_values(grid_handler_A)
    do i=1, 1
        !if (my_rank == 1) write(*,*) i
        call cycle()
    end do
    x = x_d

    ! Gather u which is the numeric derivative ---------------------------------
    call debug_values(grid_handler_C)
    v => testgrid_handler%grid_pointer_3d
    call testgrid_handler%get_dims(dims)

    func => grid_func_dt
    call create_supergrid(dims, func) ! Create Supergrid Only has to be called once
    call get_supergrid(u,dims)

    ! Check difference of u and v
    call check_diff(u,v,dims, "Theory - CommNum")

    ! Calculate theoretical Solution
    func => grid_func
    call create_supergrid(dims, func) ! Create Supergrid Only has to be called once
    call get_supergrid(u,dims)

    !if(my_rank == 0) then 
    !x = x_d
    !write(*,*) dims
    !write(*,*) "Dims (:, 1,:)"
    !write(fmt, '(A, I0, A)') '(', dims(1), 'F4.1)'
    !write(*,fmt) u(:,1 ,:)
    !end if
    w(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,3)
    
    do k=2, dims(3)-1
        do j=2, dims(2)-1
            do i = 2, dims(1)-1
                w(i,j,k) =  (u(i+1,j,k)-u(i-1,j,k))/( 2/real(dims(1))) +&
                            (u(i,j+1,k)-u(i,j-1,k))/( 2/real(dims(2))) +&
                            (u(i,j,k+1)-u(i,j,k-1))/( 2/real(dims(3))) 
            end do
            !grid3D_pointer_main(1,j,k) = 0
            !grid3D_pointer_main(-1,j,k) = 0
        end do
    end do
    func => grid_func_dt
    call create_supergrid(dims, func) ! Create Supergrid Only has to be called once
    call get_supergrid(u,dims)

    ! Check difference of u and v
    call check_diff(u,w,dims, "Theory - Num")

    call check_diff(w,v,dims, "Num - CommNum")

    if (my_rank == 0) then
    write(*,*) "theory abs"
    write(*,*) sum(abs(0-u(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)))/(dims(1)-2)/(dims(2)-2)/(dims(3)-2)
    !call check_diff(u,v,dims)
    end if
    


    ! Cleanup ==================================================================
    call MPI_Barrier(MPI_COMM_WORLD)
    if (allocated(x )) deallocate(x, stat = ierr(1))
    if (ierr(1) /= 0) print *, "q(1, grid_handler_A%total_space), : Deallocation request denied"

     if (allocated(q )) deallocate(q, stat = ierr(1))
     if (ierr(1) /= 0) print *, "q(1, grid_handler_A%total_space), : Deallocation request denied"

    ! Allocate testgrid and testbuffer . . . . . . . . . . . . . . . . . . . . 
    if (allocated(testgrid_array)) deallocate(testgrid_array, stat = ierr(1))
    if (ierr(1) /= 0) print *, "array: Deallocation request denied"

    !if (allocated(testbuffer_array)) deallocate(testbuffer_array, stat = ierr(1))
    !if (ierr(1) /= 0) print *, "array: Deallocation request denied"

    ! Calling 
    call MPI_Finalize()
    contains

    subroutine debug_values(current_grid_handler)
        class(Grid3D)            :: current_grid_handler
        call testgrid_handler%gather_compgrid(current_grid_handler, grid_comm_handler, subgrid_xyz_dims, my_rank)
        !call calc_checksum(my_rank)
    end subroutine debug_values

    subroutine cycle()

        ! Calc d/dy
        call grid_handler_A%get_pointer_3D(u_d,u)
        call grid_handler_C%get_pointer_3D(v_d,v)
        call grid_handler_A%diff_central1(v_d)
        
        ! Rotation 1----------------------------------------------------------------
        call grid_comm_handler%rotate_grid(grid_handler_A, grid_handler_B, [2,1,3], grid_handler_tmp)
        call grid_handler_B%grid_waitall()
        call grid_comm_handler%rotate_grid(grid_handler_C, grid_handler_D, [2,1,3], grid_handler_tmp)
        call grid_handler_D%grid_waitall()

        ! Calc d/dx
        call grid_handler_B%get_pointer_3D(u_d,u)
        call grid_handler_D%get_pointer_3D(v_d,v)
        call grid_handler_B%diff_central1(v_d)
        ! Rotation 2---------------------------------------------------------------
        call grid_comm_handler%rotate_grid(grid_handler_B, grid_handler_A, [3,2,1], grid_handler_tmp)
        call grid_handler_A%grid_waitall()
        call grid_comm_handler%rotate_grid(grid_handler_D, grid_handler_C, [3,2,1],grid_handler_tmp)
        call grid_handler_C%grid_waitall()

        ! Calculate d/dz
        call grid_handler_A%get_pointer_3D(u_d)
        call grid_handler_C%get_pointer_3D(v_d,v)
        call grid_handler_A%diff_central1(v_d)
        ! Rotation 3---------------------------------------------------------------
        call grid_comm_handler%rotate_grid(grid_handler_A, grid_handler_B, [3,2,1], grid_handler_tmp)
        call grid_handler_B%grid_waitall()
        call grid_comm_handler%rotate_grid(grid_handler_C, grid_handler_D, [3,2,1], grid_handler_tmp)
        call grid_handler_D%grid_waitall()

        ! Rotation 4---------------------------------------------------------------
        call grid_comm_handler%rotate_grid(grid_handler_B, grid_handler_A, [2,1,3], grid_handler_tmp)
        call grid_handler_A%grid_waitall()
        call grid_comm_handler%rotate_grid(grid_handler_D, grid_handler_C, [2,1,3],grid_handler_tmp)
        call grid_handler_C%grid_waitall()

    end subroutine cycle

    subroutine check_diff(u,v,dims, title, show_matrices)
        real(wp), pointer :: u(:, :, :) 
        real(wp), pointer :: v(:, :, :) 
        integer, dimension(3)       :: dims
        character(len = *), optional:: title
        logical, optional :: show_matrices

        if (my_rank == 0) then 
            if(present(title)) write(*,*) title
            
            write(*,*) sum(abs(u(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)-v(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)))/(dims(1)-2)/(dims(2)-2)/(dims(3)-2)

            if(present(show_matrices)) then 
                if(show_matrices) then 
                write(*,*) dims
                write(*,*) "Dims (:, 1,:)"
                write(fmt, '(A, I0, A)') '(', dims(2), 'F4.1)'
                write(*,fmt) u(2,: ,:)

                write(*,*) dims
                write(*,*) "Dims (:, 1,:)"
                write(fmt, '(A, I0, A)') '(', dims(2), 'F4.1)'
                write(*,fmt) v(2, :,:)
                end if
            end if
        end if

    end subroutine check_diff

    subroutine show_mat(u, dims, title)
        real(wp), pointer :: u(:, :, :) 
        integer, dimension(3)       :: dims
        character(len = *), optional:: title

        if(my_rank == 0) then
            if(present(title)) write(*,*) title
            write(*,*) dims
            write(*,*) "Dims (:, 1,:)"
            write(fmt, '(A, I0, A)') '(', dims(1), 'F4.1)'
            write(*,fmt) u(:, 1,:)
        end if
    end subroutine show_mat

    !subroutine create_supergrid(u,dims)
    !    real(wp), pointer :: u(:, :, :) 
    !    integer, dimension(3)       :: dims

    !    ! Create v(:,:,:) pointer --------------------------------------------------
    !    allocate(y(dims(1)*dims(2)*dims(3), 3), stat = ierr(1), pinned = pinnedFlag)
    !    if (ierr(1) /= 0) print *, "q(1, grid_handler%total_space), : Allocation request denied"
    !    u(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,1)


    !    do i = 1, dims(1)
    !        do j=1, dims(2)
    !            do k = 1, dims(3)
    !                !v(i,j,k) = Sin(-1. + 2.*real(i)/real(dims(1)*pi_wp)) + &
    !                !           real(j)/real(dims(2)) + &
    !                !           real(k)/real(dims(3))**2
    !                !v(i,j,k) = Sin((-1. + 2.*real(i)/real(dims(1)))*pi_wp) + &
    !                !           real(j)/real(dims(2)) + &
    !                !           (real(k)/real(dims(3)))**2
    !                u(i,j,k) = (-1. + 2.*real(i)/real(dims(1))) + &
    !                           (real(j)/real(dims(2))) + &
    !                           (real(k)/real(dims(3)))
    !            end do
    !        end do
    !    end do

    !    y(:,2) = y(:,1)
    !    u(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,2)

    !end subroutine create_supergrid

    subroutine get_supergrid(u,dims)
        real(wp), pointer :: u(:, :, :) 
        integer, dimension(3)       :: dims

        y(:,2) = y(:,1)
        u(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,2)
        
    end subroutine get_supergrid


end program comm_test

