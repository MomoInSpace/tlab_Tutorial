module grid_ops
    use TLAB_CONSTANTS
    use TLAB_ARRAYS 
    use TLAB_POINTERS_3D
    use grid_comm_module
    implicit none


    abstract interface
        function Ifunc(x_val, y_val, z_val) &
            result(f_val)
        import :: wp
        implicit none
        real(wp), intent(in)  :: x_val,y_val,z_val
        real(wp) :: f_val
      end function Ifunc
   end interface

    contains

    subroutine get_supergrid(u, dims)
        real(wp), pointer :: u(:, :, :) 
        integer, dimension(3)       :: dims
        !real(wp), allocatable, pinned :: y(:,:)

        y(:,2) = y(:,1)
        u(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,2)
        
    end subroutine get_supergrid

    subroutine create_supergrid(dims, func)
        real(wp), pointer :: u(:, :, :) 
        integer, dimension(3)       :: dims
        INTEGER:: i, j, k, ierr
        procedure(Ifunc), pointer :: func
        !real(wp), allocatable, pinned :: y(:,:)
        real(wp)  :: x_val,y_val,z_val

        ! Create v(:,:,:) pointer --------------------------------------------------
        allocate(y(dims(1)*dims(2)*dims(3), 3), stat = ierr)
        if (ierr /= 0) print *, "q(1, grid_handler%total_space), : Allocation request denied"
        u(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,1)


        do k = 1, dims(3)
            z_val = (real(k)/real(dims(3)))
            do j=1, dims(2)
                x_val = (real(j)/real(dims(2)))
                do i = 1, dims(1)
                    y_val = (-1. + 1.*real(i)/real(dims(1)))+0.5

                    u(i,j,k) = func(y_val,x_val,z_val)
                end do
            end do
        end do

        y(:,2) = y(:,1)
        u(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,2)

    end subroutine create_supergrid

    subroutine fill_subgrid(u,dims, func, grid_comm_handler)
        real(wp), pointer :: u(:, :, :) 
        procedure(Ifunc), pointer :: func
        integer, dimension(3)       :: dims
        INTEGER:: i, j, k, m, n, mi,ni
        real(wp)  :: x,y,z
        class(Grid3D_Comm_Handler)   :: grid_comm_handler

        mi = grid_comm_handler%MPI_Cart_Coords(1)
        ni = grid_comm_handler%MPI_Cart_Coords(2)
        m = grid_comm_handler%MPI_Cart_Dims(1)
        n = grid_comm_handler%MPI_Cart_Dims(2)
        !write(*,*) mi,ni,m,n

        do k = 1, dims(3)
            z = 1/real(m)*(real(mi) + real(k)/real(dims(3)))
            do j=1, dims(2)
                x = 1/real(n)*(real(ni) + real(j)/real(dims(2)))
                do i = 1, dims(1)
                    y = -1. + 1.*real(i)/real(dims(1)) + 0.5
                    u(i,j,k) = u(i,j,k) + func(y,x,z)
                end do
            end do
        end do

    end subroutine fill_subgrid

    real(wp) function grid_func(y,x,z) result(f)
        real(wp), intent(in)  :: x,y,z
        f = (x**3+y**3+z**3   &
          +  x**2*Sin(y)+z**3 &
          +  Sin(x*y*z))*1000
    end function

    real(wp) function grid_func_dx(y,x,z) result(f)
        real(wp), intent(in)  :: x,y,z
        f = (3*x**2 &
          +  2*x*Sin(y) &
          +  Cos(x*y*z)*y*z)*1000
    end function

    real(wp) function grid_func_dy(y,x,z) result(f)
        real(wp), intent(in)  :: x,y,z
        f = (3*y**2 &
          + x**2*Cos(y) &
          + Cos(x*y*z)*x*z)*1000
    end function

    real(wp) function grid_func_dz(y,x,z) result(f)
        real(wp), intent(in)  :: x,y,z
        f = (3*z**2 &
          + 3*z**2 &
          + Cos(x*y*z)*x*y)*1000
    end function

    real(wp) function grid_func_dt(y,x,z) result(f)
        real(wp), intent(in)  :: x,y,z
        f = grid_func_dx(y,x,z)+grid_func_dy(y,x,z)+ grid_func_dz(y,x,z)
    end function

end module grid_ops
