module grid_ops
    use TLAB_CONSTANTS
    use TLAB_ARRAYS 
    use TLAB_POINTERS_3D
    use grid_comm_module
    implicit none


    abstract interface
        function Ifunc(x_val, y_val, z_val) &
            result(f_val)
        import :: wp
        implicit none
        real(wp), intent(in)  :: x_val,y_val,z_val
        real(wp) :: f_val
      end function Ifunc
   end interface

    contains

    subroutine get_supergrid(u, dims)
        real(wp), pointer :: u(:, :, :) 
        integer, dimension(3)       :: dims
        !real(wp), allocatable, pinned :: y(:,:)

        y(:,2) = y(:,1)
        u(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,2)
        
    end subroutine get_supergrid

    subroutine create_supergrid(dims, func)
        real(wp), pointer :: u(:, :, :) 
        integer, dimension(3)       :: dims
        INTEGER:: i, j, k, ierr
        procedure(Ifunc), pointer :: func
        !real(wp), allocatable, pinned :: y(:,:)
        real(wp)  :: x_val,y_val,z_val

        ! Create v(:,:,:) pointer --------------------------------------------------
        allocate(y(dims(1)*dims(2)*dims(3), 3), stat = ierr)
        if (ierr /= 0) print *, "q(1, grid_handler%total_space), : Allocation request denied"
        u(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,1)


        do k = 1, dims(3)
            z_val = (real(k)/real(dims(3)))
            do j=1, dims(2)
                x_val = (real(j)/real(dims(2)))
                do i = 1, dims(1)
                    y_val = (-1. + 1.*real(i)/real(dims(1)))+0.5

                    u(i,j,k) = func(y_val,x_val,z_val)
                end do
            end do
        end do

        y(:,2) = y(:,1)
        u(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,2)

    end subroutine create_supergrid

    subroutine fill_subgrid(u,dims, func, grid_comm_handler)
        real(wp), pointer :: u(:, :, :) 
        procedure(Ifunc), pointer :: func
        integer, dimension(3)       :: dims
        INTEGER:: i, j, k, m, n, mi,ni
        real(wp)  :: x,y,z
        class(Grid3D_Comm_Handler)   :: grid_comm_handler

        mi = grid_comm_handler%MPI_Cart_Coords(1)
        ni = grid_comm_handler%MPI_Cart_Coords(2)
        m = grid_comm_handler%MPI_Cart_Dims(1)
        n = grid_comm_handler%MPI_Cart_Dims(2)
        !write(*,*) mi,ni,m,n

        do k = 1, dims(3)
            z = 1/real(m)*(real(mi) + real(k)/real(dims(3)))
            do j=1, dims(2)
                x = 1/real(n)*(real(ni) + real(j)/real(dims(2)))
                do i = 1, dims(1)
                    y = -1. + 1.*real(i)/real(dims(1)) + 0.5
                    u(i,j,k) = u(i,j,k) + func(y,x,z)
                end do
            end do
        end do

    end subroutine fill_subgrid

    subroutine calc_serial_derivative(w,u, dims)
        real(wp), pointer :: w(:, :, :) 
        real(wp), pointer :: u(:, :, :) 
        integer, dimension(3)       :: dims
        INTEGER:: i, j, k

        w(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,3)
        
        do k=2, dims(3)-1
            do j=2, dims(2)-1
                do i = 2, dims(1)-1
                    w(i,j,k) =  (u(i+1,j,k)-u(i-1,j,k))/( 2/real(dims(1))) +&
                                (u(i,j+1,k)-u(i,j-1,k))/( 2/real(dims(2))) +&
                                (u(i,j,k+1)-u(i,j,k-1))/( 2/real(dims(3))) 
                end do
                !grid3D_pointer_main(1,j,k) = 0
                !grid3D_pointer_main(-1,j,k) = 0
            end do
        end do
    end subroutine calc_serial_derivative

    subroutine check_diff(u,v,dims, title, show_matrices)
        use mpi_f08
        real(wp), pointer :: u(:, :, :) 
        real(wp), pointer :: v(:, :, :) 
        integer, dimension(3)       :: dims
        integer                     :: my_rank
        character(len = *), optional:: title
        logical, optional :: show_matrices
        character(len = 100):: fmt

        call MPI_Comm_rank(MPI_COMM_WORLD, my_rank)

        if (my_rank == 0) then 
            if(present(title)) write(*,*) title, " = {"
            
            print*, '"MeanSum" : ', sum(abs(u(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1))+abs(v(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)))/2/&
            (dims(1)-2)/(dims(2)-2)/(dims(3)-2), ','

            print*, '"MeanDiff" :', sum(abs(u(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)-v(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)))/&
            (dims(1)-2)/(dims(2)-2)/(dims(3)-2), ','

            print*, '"RelDiff" :', sum(abs(u(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)-v(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)))/&
            (sum(abs(u(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)))+&
            sum(abs(-v(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1))))*2, ","

            print*, '"Linf" :', maxval(abs(u(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)-v(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1))), "}"

            if(present(show_matrices)) then 
                if(show_matrices) then 
                write(*,*) dims
                write(*,*) "Dims (:, 1,:)"
                write(fmt, '(A, I0, A)') '(', dims(2), 'F4.1)'
                write(*,fmt) u(2,: ,:)

                write(*,*) dims
                write(*,*) "Dims (:, 1,:)"
                write(fmt, '(A, I0, A)') '(', dims(2), 'F4.1)'
                write(*,fmt) v(2, :,:)
                end if
            end if
        end if

    end subroutine check_diff


    real(wp) function grid_func(y,x,z) result(f)
        real(wp), intent(in)  :: x,y,z
        f = (x**3+y**3+z**3   &
          +  x**2*Sin(y)+z**3 &
          +  Sin(x*y*z))*10
    end function

    real(wp) function grid_func_dx(y,x,z) result(f)
        real(wp), intent(in)  :: x,y,z
        f = (3*x**2 &
          +  2*x*Sin(y) &
          +  Cos(x*y*z)*y*z)*10
    end function

    real(wp) function grid_func_dy(y,x,z) result(f)
        real(wp), intent(in)  :: x,y,z
        f = (3*y**2 &
          + x**2*Cos(y) &
          + Cos(x*y*z)*x*z)*10
    end function

    real(wp) function grid_func_dz(y,x,z) result(f)
        real(wp), intent(in)  :: x,y,z
        f = (3*z**2 &
          + 3*z**2 &
          + Cos(x*y*z)*x*y)*10
    end function

    real(wp) function grid_func_dt(y,x,z) result(f)
        real(wp), intent(in)  :: x,y,z
        f = grid_func_dx(y,x,z)+grid_func_dy(y,x,z)+ grid_func_dz(y,x,z)
    end function

end module grid_ops
