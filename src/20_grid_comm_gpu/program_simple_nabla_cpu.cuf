program comm_test
    use mpi_f08
    use TLAB_CONSTANTS
    use TLAB_ARRAYS 
    use TLAB_POINTERS_3D
    !use grid_handler
    use grid_handler_cpu
    use grid_comm_module
    use grid_comm_cpu_module
    use grid_debug
    implicit none 

    ! Parameters================================================================
    ! Input Grid Data
    INTEGER:: i, j, k, m, n, mi,ni
    character(len = 100):: fmt
    CHARACTER(len = 32):: arg

    integer                     :: world_size, my_rank
    type(Grid3D_Comm_cpu)   :: grid_comm_handler
    type(Grid3D_cpu), target    :: grid_handler_A, grid_handler_B, grid_handler_tmp, grid_handler_C, grid_handler_D
    type(Complete_grid_debugger):: testgrid_handler
    integer, dimension(3)       :: state_xyz  = [2, 1, 3], &
                                   ! Pertubation of [1, 2, 3]. 
                                   ! Describes the orientation of our array/grid. 
                                   block_xyz_dims, &
                                   ! Describes the size of the smallest grid_unit.
                                   block_multiplication_xyz_state = [1, 1, 0], &
                                   ! The block_xyz_dims get multiplied by the 
                                   ! threads as indicated by this state.
                                   ! Depending on the communication algorithm used, 
                                   ! the programm needs different states!
                                   subgrid_xyz_dims, &
                                   ! The size of the subgrid for each thread as 
                                   ! indicated by block_multiplication_xyz_state
                                   dims
    integer                     :: column_upper_limit
    integer, dimension(2)       :: task_state, rank_coords

    ! Error Integer
    INTEGER, dimension(100)     :: ierr  = 0

    integer                     :: send_num, overhead_factor
    logical                     :: pinnedFlag

    ! Body======================================================================
    ! Initialisation------------------------------------------------------------

    ! MPI Initialisation
    call MPI_Init()
    call MPI_Comm_rank(MPI_COMM_WORLD, my_rank)
    call MPI_Comm_size(MPI_COMM_WORLD, world_size)

     ! Read Input Parameters from Terminal---------------------------------------
     if (my_rank == 0) then
        do i = 1, COMMAND_ARGUMENT_COUNT()  ! Should be 3
            ! Get Arguments:
            call getarg(i, arg)
            READ(arg, '(I10)') block_xyz_dims(i)
            end do
     end if

    ! Define Complete Grid------------------------------------------------------
    ! Broadcast Input Parameters and use pointers for better readability
    call MPI_BCAST(block_xyz_dims, 3, MPI_INTEGER, 0, MPI_COMM_WORLD)
    column_upper_limit = block_xyz_dims(2)

    !Init grid_comm_handler-----------------------------------------------------
    ! Four possible states: [0, 1, 2, 12].
    grid_comm_handler = Grid3D_Comm_cpu(world_size, &
            block_xyz_dims, &
            block_multiplication_xyz_state, &
            column_upper_limit)
    subgrid_xyz_dims = grid_comm_handler%subgrid_xyz_dims  

    ! Init grid_handler derived types-------------------------------------------
    overhead_factor = 3
    grid_handler_A = Grid3D_cpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)
    grid_handler_B = Grid3D_cpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)
    grid_handler_C = Grid3D_cpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)
    grid_handler_D = Grid3D_cpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)
    grid_handler_tmp = Grid3D_cpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)

    allocate(x(grid_handler_A%total_space, 5), stat = ierr(1), pinned = pinnedFlag)
    if (ierr(1) /= 0) print *, "q(1, grid_handler%total_space), : Allocation request denied"

    !allocate(x_d(grid_handler_A%total_space, 5), stat = ierr(1))
    !if (ierr(1) /= 0) print *, "q(1, grid_handler%total_space), : Allocation request denied"

    call grid_handler_A%set_pointer_1D(x(:,1))
    call grid_handler_B%set_pointer_1D(x(:,2))
    call grid_handler_C%set_pointer_1D(x(:,3))
    call grid_handler_D%set_pointer_1D(x(:,4))
    call grid_handler_tmp%set_pointer_1D(x(:,5))

    ! Example: For later use
    !call grid_handler_A%get_pointer_3D(u)


    ! Set Values For visualization----------------------------------------------
    dims = grid_handler_A%get_dims()
    rank_coords = grid_comm_handler%MPI_Cart_Coords
    mi = rank_coords(1)
    ni = rank_coords(2)
    rank_coords = grid_comm_handler%MPI_Cart_Dims
    m = rank_coords(1)
    n = rank_coords(2)


    ! Check Local Diff
    call check_local_derivative(grid_handler_A, grid_handler_B, grid_handler_C)

    ! Check gather
    call grid_handler_A%get_pointer_3D(u)
    call fill_subgrid(u)
    call debug_values(grid_handler_A)
    call testgrid_handler%get_dims(dims)
    u => testgrid_handler%grid_pointer_3d
    call create_supergrid(v,dims) ! Create Supergrid Only has to be called once
    call get_supergrid(v,dims)
    if (my_rank == 0) then
        write(*,*) "Check Gather"
        call check_diff(u,v,dims)

        !write(*,*) "Gathered Grid:"
        !write(*,*) dims
        !!write(*,*) "Dims (:, 1,:)"
        !write(fmt, '(A, I0, A)') '(', dims(1), 'F4.1)'
        !write(*,fmt) u(:, 2,:)  

        !write(*,*) "Generated Grid:"
        !write(*,*) dims
        !!write(*,*) "Dims (:, 1,:)"
        !write(fmt, '(A, I0, A)') '(', dims(1), 'F4.1)'
        !write(*,fmt) v(:, 2,:)
    end if

    !Check Gather+Diff
    call grid_handler_A%get_pointer_3D(u)
    call fill_subgrid(u)
    u = u**3
    grid_handler_B%grid_space_main = 99
    grid_handler_C%grid_space_main= 0
    !x_d = x

    ! Visualize Complete Grid---------------------------------------------------
    !call debug_values(grid_handler_A)
    do i=1, 1
        !if (my_rank == 1) write(*,*) i
        call cycle()
    end do
    !x = x_d

    ! Gather u which is the numeric derivative ---------------------------------
    call debug_values(grid_handler_C)
    v => testgrid_handler%grid_pointer_3d
    call testgrid_handler%get_dims(dims)

    call get_supergrid(u,dims)
    u = 3*u**2

    ! Calculate theoretical Solution
    if (my_rank == 0) then 
        ! Print out theoretic Solution
        !write(*,*) "Theory"
        !!write(*,*) dims
        !write(*,*) "Dims (:, 1,:)"
        !write(fmt, '(A, I0, A)') '(', dims(1)-2, 'F4.1)'
        !write(*,fmt) u(2:dims(1)-1, 2,2:dims(3)-1)

        !!! Print out numeric Solution
        !write(*,*) "CommNum"
        !write(*,*) "Dims (:, 1,:)"
        !write(fmt, '(A, I0, A)') '(', dims(1)-2, 'F4.1)'
        !write(*,fmt) v(2:dims(1)-1, 2,2:dims(3)-1)

        ! Check difference of u and v
        write(*,*) "Theory - CommNum"
        call check_diff(u,v,dims)

        call get_supergrid(u,dims)
        w(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,3)
        u = u**3
        
        do k=2, dims(3)-1
            do j=2, dims(2)-1
                do i = 2, dims(1)-1
                    w(i,j,k) =  (u(i+1,j,k)-u(i-1,j,k))/( 2*(2/real(dims(1))) ) !+&
                                !(u(i,j+1,k)-u(i,j-1,k))/( 2*(2/real(dims(2))) ) +&
                                !(u(i,j,k+1)-u(i,j,k-1))/( 2*(2/real(dims(3))) )
                end do
                !grid3D_pointer_main(1,j,k) = 0
                !grid3D_pointer_main(-1,j,k) = 0
            end do
        end do
        call get_supergrid(u,dims)
        u = 3*u**2

        ! Check difference of u and v
        write(*,*) "Theory - Num"
        call check_diff(w,u,dims)

        write(*,*) "Num - CommNum"
        call check_diff(v,u,dims)

        write(*,*) "theory abs"
        write(*,*) sum(abs(0-u(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)))/(dims(1)-2)/(dims(2)-2)/(dims(3)-2)
        !call check_diff(u,v,dims)
    end if
    


    ! Cleanup ==================================================================
    call MPI_Barrier(MPI_COMM_WORLD)
    if (allocated(x )) deallocate(x, stat = ierr(1))
    if (ierr(1) /= 0) print *, "q(1, grid_handler_A%total_space), : Deallocation request denied"

     if (allocated(q )) deallocate(q, stat = ierr(1))
     if (ierr(1) /= 0) print *, "q(1, grid_handler_A%total_space), : Deallocation request denied"

    ! Allocate testgrid and testbuffer . . . . . . . . . . . . . . . . . . . . 
    if (allocated(testgrid_array)) deallocate(testgrid_array, stat = ierr(1))
    if (ierr(1) /= 0) print *, "array: Deallocation request denied"

    !if (allocated(testbuffer_array)) deallocate(testbuffer_array, stat = ierr(1))
    !if (ierr(1) /= 0) print *, "array: Deallocation request denied"

    ! Calling 
    call MPI_Finalize()
    contains

    subroutine debug_values(current_grid_handler)
        class(Grid3D)            :: current_grid_handler
        call testgrid_handler%gather_compgrid(current_grid_handler, grid_comm_handler, subgrid_xyz_dims, my_rank)
        !call testgrid_handler%visualize_grid(my_rank)
        !call calc_checksum(my_rank)
    end subroutine debug_values

    subroutine cycle()

        !call grid_handler_C%get_pointer_3D(u_d, u)
        !call grid_handler_A%diff_central1(u_d)

        !if (my_rank == 0) then 
        !    ! Print out numeric Solution
        !    write(*,*) dims
        !    write(*,*) "Dims (:, 1,:)"
        !    write(fmt, '(A, I0, A)') '(', dims(1), 'F4.1)'
        !    write(*,fmt) u(:, 1,:)
        !end if

        !x = x_d
        call MPI_Barrier(MPI_COMM_WORLD)
        call grid_handler_A%get_pointer_3D(u)
        call grid_handler_C%get_pointer_3D(v)
        call grid_handler_A%diff_central1(v)
        call MPI_Barrier(MPI_COMM_WORLD)

        ! Rotation 1----------------------------------------------------------------
        call grid_comm_handler%rotate_grid(grid_handler_A, grid_handler_B, [2,1,3], grid_handler_tmp)
        call grid_handler_B%grid_waitall()
        call MPI_Barrier(MPI_COMM_WORLD)
        call grid_comm_handler%rotate_grid(grid_handler_C, grid_handler_D, [2,1,3], grid_handler_tmp)
        call grid_handler_D%grid_waitall()
        call MPI_Barrier(MPI_COMM_WORLD)
        !call grid_handler_B%get_pointer_3D(u_d)

        !call MPI_Barrier(MPI_COMM_WORLD)
        !call grid_handler_D%get_pointer_3D(u_d, u)
        !call grid_handler_B%diff_central1(u_d)
        !x = x_d
        !call MPI_Barrier(MPI_COMM_WORLD)

        !call MPI_Barrier(MPI_COMM_WORLD)
        !call grid_handler_B%get_pointer_3D(u)
        !call grid_handler_D%get_pointer_3D(v)
        !call grid_handler_B%diff_central1(v)
        !call MPI_Barrier(MPI_COMM_WORLD)

        ! Rotation 2---------------------------------------------------------------
        call grid_comm_handler%rotate_grid(grid_handler_B, grid_handler_A, [3,2,1], grid_handler_tmp)
        call grid_handler_A%grid_waitall()
        call MPI_Barrier(MPI_COMM_WORLD)
        call grid_comm_handler%rotate_grid(grid_handler_D, grid_handler_C, [3,2,1],grid_handler_tmp)
        call grid_handler_C%grid_waitall()
        call MPI_Barrier(MPI_COMM_WORLD)

        !call MPI_Barrier(MPI_COMM_WORLD)
        !call grid_handler_A%get_pointer_3D(u)
        !call grid_handler_C%get_pointer_3D(v)
        !call grid_handler_A%diff_central1(v)
        !call MPI_Barrier(MPI_COMM_WORLD)
        ! Rotation 3---------------------------------------------------------------
        call grid_comm_handler%rotate_grid(grid_handler_A, grid_handler_B, [3,2,1], grid_handler_tmp)
        call grid_handler_B%grid_waitall()
        call MPI_Barrier(MPI_COMM_WORLD)
        call grid_comm_handler%rotate_grid(grid_handler_C, grid_handler_D, [3,2,1], grid_handler_tmp)
        call grid_handler_D%grid_waitall()
        call MPI_Barrier(MPI_COMM_WORLD)

        ! Rotation 4---------------------------------------------------------------
        call grid_comm_handler%rotate_grid(grid_handler_B, grid_handler_A, [2,1,3], grid_handler_tmp)
        call grid_handler_A%grid_waitall()
        call MPI_Barrier(MPI_COMM_WORLD)
        call grid_comm_handler%rotate_grid(grid_handler_D, grid_handler_C, [2,1,3],grid_handler_tmp)
        call grid_handler_C%grid_waitall()
        call MPI_Barrier(MPI_COMM_WORLD)

        !if (my_rank == 0) then 
        !    ! Print out numeric Solution
        !    write(*,*) dims
        !    write(*,*) "Dims (:, 1,:)"
        !    write(fmt, '(A, I0, A)') '(', dims(1), 'F4.1)'
        !    write(*,fmt) u(:, 1,:)
        !end if


    end subroutine cycle

    subroutine fill_subgrid(u)
        real(wp), pointer :: u(:, :, :) 

        do i = 1, dims(1)
            do j=1, dims(2)
                do k = 1, dims(3)
                    !u(i,j,k) = Sin((-1. + 2.*real(i)/real(dims(1)))*pi_wp) + &
                    !           1/real(n)*(real(ni) + real(j)/real(dims(2))) + &
                    !           (1/real(m)*(real(mi) + real(k)/real(dims(3))))**2
                    u(i,j,k) = (-1. + 2.*real(i)/real(dims(1))) + &
                               (1/real(n)*(real(ni) + real(j)/real(dims(2)))) + &
                               (1/real(m)*(real(mi) + real(k)/real(dims(3))))
                end do
            end do
        end do

    end subroutine fill_subgrid

    subroutine check_local_derivative(grid_handler_A, grid_handler_B, grid_handler_C)
        type(Grid3D_cpu), target    :: grid_handler_A, grid_handler_B, grid_handler_C
        integer, dimension(3)       :: dims

        call grid_handler_A%get_pointer_3D(u)
        call fill_subgrid(u)
        call grid_handler_B%get_pointer_3D(v)
        v = u**3
        call grid_handler_C%get_pointer_3D(w)
        call grid_handler_B%diff_central1(w)

        v = 3*u**2
        dims = grid_handler_A%get_dims()
            
        if (my_rank == 0) then
        write(*,*) "Local Diff:"
        call check_diff(v,w,dims)
        end if
        
    end subroutine check_local_derivative

    subroutine check_diff(u,v,dims)
        real(wp), pointer :: u(:, :, :) 
        real(wp), pointer :: v(:, :, :) 
        integer, dimension(3)       :: dims

        write(*,*) sum(abs(u(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)-v(2:dims(1)-1, 2:dims(2)-1,2:dims(3)-1)))/(dims(1)-2)/(dims(2)-2)/(dims(3)-2)

        !write(*,*) dims
        !write(*,*) "Dims (:, 1,:)"
        !write(fmt, '(A, I0, A)') '(', dims(1), 'F4.1)'
        !write(*,fmt) u(:, 1,:)

        !write(*,*) dims
        !write(*,*) "Dims (:, 1,:)"
        !write(fmt, '(A, I0, A)') '(', dims(1), 'F4.1)'
        !write(*,fmt) w(:, 1,:)
    end subroutine check_diff

    subroutine create_supergrid(u,dims)
        real(wp), pointer :: u(:, :, :) 
        integer, dimension(3)       :: dims

        ! Create v(:,:,:) pointer --------------------------------------------------
        allocate(y(dims(1)*dims(2)*dims(3), 3), stat = ierr(1), pinned = pinnedFlag)
        if (ierr(1) /= 0) print *, "q(1, grid_handler%total_space), : Allocation request denied"
        u(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,1)


        do i = 1, dims(1)
            do j=1, dims(2)
                do k = 1, dims(3)
                    !v(i,j,k) = Sin(-1. + 2.*real(i)/real(dims(1)*pi_wp)) + &
                    !           real(j)/real(dims(2)) + &
                    !           real(k)/real(dims(3))**2
                    !v(i,j,k) = Sin((-1. + 2.*real(i)/real(dims(1)))*pi_wp) + &
                    !           real(j)/real(dims(2)) + &
                    !           (real(k)/real(dims(3)))**2
                    u(i,j,k) = (-1. + 2.*real(i)/real(dims(1))) + &
                               (real(j)/real(dims(2))) + &
                               (real(k)/real(dims(3)))
                end do
            end do
        end do

        y(:,2) = y(:,1)
        u(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,2)

    end subroutine create_supergrid

    subroutine get_supergrid(u,dims)
        real(wp), pointer :: u(:, :, :) 
        integer, dimension(3)       :: dims

        y(:,2) = y(:,1)
        u(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,2)
        

    end subroutine get_supergrid


end program comm_test

