program comm_test
    use mpi_f08
    use TLAB_CONSTANTS
    use TLAB_ARRAYS 
    use TLAB_POINTERS_3D
    !use grid_handler
    use grid_handler_gpu
    use grid_comm_module
    use grid_comm_gpu_module
    use grid_debug
    implicit none 

    ! Parameters================================================================
    ! Input Grid Data
    INTEGER:: i, j, k, m, n, mi,ni
    character(len = 100):: fmt
    CHARACTER(len = 32):: arg

    integer                     :: world_size, my_rank
    type(Grid3D_Comm_gpu)   :: grid_comm_handler
    type(Grid3D_gpu), target    :: grid_handler_A, grid_handler_B, grid_handler_tmp, grid_handler_C, grid_handler_D
    type(Complete_grid_debugger):: testgrid_handler
    integer, dimension(3)       :: state_xyz  = [2, 1, 3], &
                                   ! Pertubation of [1, 2, 3]. 
                                   ! Describes the orientation of our array/grid. 
                                   block_xyz_dims, &
                                   ! Describes the size of the smallest grid_unit.
                                   block_multiplication_xyz_state = [1, 1, 0], &
                                   ! The block_xyz_dims get multiplied by the 
                                   ! threads as indicated by this state.
                                   ! Depending on the communication algorithm used, 
                                   ! the programm needs different states!
                                   subgrid_xyz_dims, &
                                   ! The size of the subgrid for each thread as 
                                   ! indicated by block_multiplication_xyz_state
                                   dims
    integer                     :: column_upper_limit
    integer, dimension(2)       :: task_state, rank_coords

    ! Error Integer
    INTEGER, dimension(100)     :: ierr  = 0

    integer                     :: send_num, overhead_factor
    logical                     :: pinnedFlag

    ! Body======================================================================
    ! Initialisation------------------------------------------------------------

    ! MPI Initialisation
    call MPI_Init()
    call MPI_Comm_rank(MPI_COMM_WORLD, my_rank)
    call MPI_Comm_size(MPI_COMM_WORLD, world_size)

     ! Read Input Parameters from Terminal---------------------------------------
     if (my_rank == 0) then
        do i = 1, COMMAND_ARGUMENT_COUNT()  ! Should be 3
            ! Get Arguments:
            call getarg(i, arg)
            READ(arg, '(I10)') block_xyz_dims(i)
            end do
     end if

    ! Define Complete Grid------------------------------------------------------
    ! Broadcast Input Parameters and use pointers for better readability
    call MPI_BCAST(block_xyz_dims, 3, MPI_INTEGER, 0, MPI_COMM_WORLD)
    column_upper_limit = block_xyz_dims(2)

    !Init grid_comm_handler-----------------------------------------------------
    ! Four possible states: [0, 1, 2, 12].
    grid_comm_handler = Grid3D_Comm_gpu(world_size, &
            block_xyz_dims, &
            block_multiplication_xyz_state, &
            column_upper_limit)
    subgrid_xyz_dims = grid_comm_handler%subgrid_xyz_dims  

    ! Init grid_handler derived types-------------------------------------------
    overhead_factor = 3
    grid_handler_A = Grid3D_gpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)
    grid_handler_B = Grid3D_gpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)
    grid_handler_C = Grid3D_gpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)
    grid_handler_D = Grid3D_gpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)
    grid_handler_tmp = Grid3D_gpu(state_xyz, subgrid_xyz_dims, overhead_factor, grid_comm_handler%MPI_Cart_Dims)

    allocate(x(grid_handler_A%total_space, 5), stat = ierr(1), pinned = pinnedFlag)
    if (ierr(1) /= 0) print *, "q(1, grid_handler%total_space), : Allocation request denied"

    allocate(x_d(grid_handler_A%total_space, 5), stat = ierr(1))
    if (ierr(1) /= 0) print *, "q(1, grid_handler%total_space), : Allocation request denied"

    call grid_handler_A%set_pointer_1D(x_d(:,1), x(:,1))
    call grid_handler_B%set_pointer_1D(x_d(:,2), x(:,2))
    call grid_handler_C%set_pointer_1D(x_d(:,3), x(:,3))
    call grid_handler_D%set_pointer_1D(x_d(:,4), x(:,4))
    call grid_handler_tmp%set_pointer_1D(x_d(:,5), x(:,5))

    ! Example: For later use
    !call grid_handler_A%get_pointer_3D(u)


    ! Set Values For visualization----------------------------------------------
    dims = grid_handler_A%get_dims()
    rank_coords = grid_comm_handler%MPI_Cart_Coords
    mi = rank_coords(1)
    ni = rank_coords(2)
    rank_coords = grid_comm_handler%MPI_Cart_Dims
    m = rank_coords(1)
    n = rank_coords(2)
    call grid_handler_A%get_pointer_3D(u_d, u)


    do i = 1, dims(1)
        do j=1, dims(2)
            do k = 1, dims(3)
                !u(i,j,k) = Sin((-1. + 2.*real(i)/real(dims(1)))*pi_wp) + &
                !           1/real(n)*(real(ni) + real(j)/real(dims(2))) + &
                !           (1/real(m)*(real(mi) + real(k)/real(dims(3))))**2
                u(i,j,k) = (-1. + 2.*real(i)/real(dims(1))) + &
                           (1/real(n)*(real(ni) + real(j)/real(dims(2)))) + &
                           (1/real(m)*(real(mi) + real(k)/real(dims(3))))
            end do
        end do
    end do



    call grid_handler_A%get_pointer_3D(u_d, u)
    call grid_handler_B%get_pointer_3D(v_d, v)
    call grid_handler_C%get_pointer_3D(w_d, w)
    v = u**2
    x_d = x
    call grid_handler_B%diff_central1(w_d)
    x = x_d
    u = 2*u

    if (my_rank == 0) then
        write(*,*) sum(abs(u(2:-2,2:-2,2:-2)-w(2:-2,2:-2,2:-2)))

        write(*,*) dims
        write(*,*) "Dims (:, 1,:)"
        write(fmt, '(A, I0, A)') '(', dims(1), 'F4.1)'
        write(*,fmt) u(:, 1,:)

        write(*,*) dims
        write(*,*) "Dims (:, 1,:)"
        write(fmt, '(A, I0, A)') '(', dims(1), 'F4.1)'
        write(*,fmt) w(:, 1,:)
    end if

    u = u/2
    u = u**2
    grid_handler_B%grid_space_sync = 99
    grid_handler_C%grid_space_sync = 0
    x_d = x


    ! Visualize Complete Grid---------------------------------------------------
    !call debug_values(grid_handler_A)
    do i=1, 1
        !if (my_rank == 1) write(*,*) i
        call cycle()
    end do
    x = x_d

    ! Gather u which is the numeric derivative ---------------------------------
    call debug_values(grid_handler_C)
    u => testgrid_handler%grid_pointer_3d
    call testgrid_handler%get_dims(dims)

    ! Create v(:,:,:) pointer --------------------------------------------------
    allocate(y(size(u), 1), stat = ierr(1), pinned = pinnedFlag)
    if (ierr(1) /= 0) print *, "q(1, grid_handler%total_space), : Allocation request denied"
    v(1:dims(1), 1:dims(2), 1:dims(3)) => y(:,1)

    ! Calculate theoretical Solution
    if (my_rank == 0) then 
        !write(*,*) u
        do i = 1, dims(1)
            do j=1, dims(2)
                do k = 1, dims(3)
                    !v(i,j,k) = Sin(-1. + 2.*real(i)/real(dims(1)*pi_wp)) + &
                    !           real(j)/real(dims(2)) + &
                    !           real(k)/real(dims(3))**2
                    !v(i,j,k) = Sin((-1. + 2.*real(i)/real(dims(1)))*pi_wp) + &
                    !           real(j)/real(dims(2)) + &
                    !           (real(k)/real(dims(3)))**2
                    v(i,j,k) = (-1. + 2.*real(i)/real(dims(1))) + &
                               (real(j)/real(dims(2))) + &
                               (real(k)/real(dims(3)))
                end do
            end do
        end do
        v = 2*v


        ! Print out numeric Solution
        write(*,*) dims
        write(*,*) "Dims (:, 1,:)"
        write(fmt, '(A, I0, A)') '(', dims(1), 'F4.1)'
        write(*,fmt) u(:, 2,:)

        ! Print out numeric Solution
        write(*,*) "Dims (:, 1,:)"
        write(fmt, '(A, I0, A)') '(', dims(1), 'F4.1)'
        write(*,fmt) v(:, 2,:)

        ! Check difference of u and v
        write(*,*) sum(abs(u(2:-2,2:-2,2:-2)-v(2:-2,2:-2,2:-2)))
    end if
    


    ! Cleanup ==================================================================
    if (allocated(x )) deallocate(x, stat = ierr(1))
    if (ierr(1) /= 0) print *, "q(1, grid_handler_A%total_space), : Deallocation request denied"

     if (allocated(q )) deallocate(q, stat = ierr(1))
     if (ierr(1) /= 0) print *, "q(1, grid_handler_A%total_space), : Deallocation request denied"

    ! Allocate testgrid and testbuffer . . . . . . . . . . . . . . . . . . . . 
    if (allocated(testgrid_array)) deallocate(testgrid_array, stat = ierr(1))
    if (ierr(1) /= 0) print *, "array: Deallocation request denied"

    !if (allocated(testbuffer_array)) deallocate(testbuffer_array, stat = ierr(1))
    !if (ierr(1) /= 0) print *, "array: Deallocation request denied"

    ! Calling 
    call MPI_Finalize()
    contains

    subroutine debug_values(current_grid_handler)
        class(Grid3D)            :: current_grid_handler
        call testgrid_handler%gather_compgrid(current_grid_handler, grid_comm_handler, subgrid_xyz_dims, my_rank)
        !call testgrid_handler%visualize_grid(my_rank)
        !call calc_checksum(my_rank)
    end subroutine debug_values

    subroutine cycle()

        call grid_handler_C%get_pointer_3D(u_d, u)
        call grid_handler_A%diff_central1(u_d)

        ! Rotation 1----------------------------------------------------------------
        call grid_comm_handler%rotate_grid(grid_handler_A, grid_handler_B, [2,1,3], grid_handler_tmp)
        call grid_comm_handler%rotate_grid(grid_handler_C, grid_handler_D, [2,1,3], grid_handler_tmp)
        call grid_handler_B%grid_waitall()
        call grid_handler_D%grid_waitall()
        !call grid_handler_B%get_pointer_3D(u_d)

        !call grid_handler_A%central_diff1()
        ! Rotation 2---------------------------------------------------------------
        call grid_comm_handler%rotate_grid(grid_handler_B, grid_handler_A, [3,2,1], grid_handler_tmp)
        call grid_comm_handler%rotate_grid(grid_handler_D, grid_handler_C, [3,2,1],grid_handler_tmp)
        call grid_handler_A%grid_waitall()
        call grid_handler_C%grid_waitall()

        !call grid_handler_A%central_diff1()
        ! Rotation 3---------------------------------------------------------------
        call grid_comm_handler%rotate_grid(grid_handler_A, grid_handler_B, [3,2,1], grid_handler_tmp)
        call grid_comm_handler%rotate_grid(grid_handler_C, grid_handler_D, [3,2,1], grid_handler_tmp)
        call grid_handler_B%grid_waitall()
        call grid_handler_D%grid_waitall()

        ! ! Rotation 4---------------------------------------------------------------
        call grid_comm_handler%rotate_grid(grid_handler_B, grid_handler_A, [3,2,1], grid_handler_tmp)
        call grid_comm_handler%rotate_grid(grid_handler_D, grid_handler_C, [2,1,3],grid_handler_tmp)
        call grid_handler_A%grid_waitall()
        call grid_handler_C%grid_waitall()

    end subroutine cycle

end program comm_test

