module grid_handler 

use TLAB_CONSTANTS, only: wp
use mpi_f08

implicit none


    ! private:: prod

  ! Define the Point type
    type, abstract:: Grid3D
        ! Grid3D handles the structure of the 3D grid.

        integer, dimension(3):: state_xyz
        ! state_xyz describes the orientation of the grid. state_xyz(1) = 2
        !  means, that the second dimension in the structured grid can be
        !  understood as the 'x' coordinate.

        integer, dimension(3):: grid_xyz_dims, complete_grid_xyz_dims 
        ! grid_xyz_dims saves the length of each dimension x, y and z

        integer:: overhead_factor, free_space, total_space, comm_steps
        ! overhead gives you the factor of the overhead that needs to be
        !  there for a fast communication. A factor of 2 means that when we communicate
        ! the 321, we will switch between 2 stencils and then wait until the next write.
        ! free_space is the differene of indices between 
        !  grid_space and allocated_space
        TYPE(MPI_Request), dimension(:), &
                           managed, &
                           allocatable   :: GRID_COMM_REQUESTS
        TYPE(MPI_Status), dimension(:), &
                          managed, &
                          allocatable    :: GRID_COMM_STATUS

    contains
        procedure:: get_dims
        procedure:: perturb_state
        procedure(iface_set_pointer_1D), deferred:: set_pointer_1D
        procedure(iface_get_pointer_3D), deferred:: get_pointer_3D
        procedure(iface_get_switch_dims_workspace), &
                  deferred :: get_switch_dims_workspace
        !procedure:: allocate_array
        !procedure:: print_state_cpu
        procedure::init_comm_requests
        procedure::grid_waitall

    end type Grid3D



    interface Grid3D
       module procedure :: createGrid3D
    end interface
    
    interface
      subroutine iface_set_pointer_1D(self, grid_array_main, grid_array_sync)
        import Grid3D
        implicit none
        class(Grid3D), intent(inout) :: self
        real, intent(in),   &
              dimension(:) :: grid_array_main
        real, intent(in),   &
              optional, &
              dimension(:)  :: grid_array_sync
         end subroutine iface_set_pointer_1D

        subroutine iface_get_pointer_3D(self, grid3D_pointer_main, grid3D_pointer_sync)
        import Grid3D
        implicit none
        class(Grid3D), intent(in) :: self
        real, intent(inout),&
              pointer, &
              dimension(:,:,:):: grid3D_pointer_main
        real, intent(inout), &
              optional, &
              pointer, &
              dimension(:,:,:):: grid3D_pointer_sync
      end subroutine iface_get_pointer_3D

      subroutine iface_get_switch_dims_workspace(self, dims, work_space3D_main, work_space_main, grid_3D_pointer_main, pertubation)
        import Grid3D
        implicit none
        class(Grid3D),   intent(in)   :: self
        integer,         intent(out), &
           dimension(3)               :: dims
        integer,         intent(in), &
           dimension(3)               :: pertubation
        real, intent(out), &
             pointer, &
             dimension(:,:,:)         :: work_space3D_main, grid_3D_pointer_main
        real, intent(out), &
             pointer, &
             dimension(:)         :: work_space_main
     end subroutine

    end interface



contains

    pure class(Grid3D) function createGrid3D(state_xyz, grid_xyz_dims, & 
                          overhead_factor, MPI_Cart_Dims) result(self)
        ! Parameters================================================================
        class(Grid3D) :: self
        integer, intent(in), &
                 dimension(3)   :: state_xyz, grid_xyz_dims
        !integer, dimension(3)   :: subgrid_factors
        integer, intent(in), &
                 dimension(2)   :: MPI_Cart_Dims
        integer, intent(in)     :: overhead_factor 
        integer                 :: max_area
        ! Notes=====================================================================
        ! Initialization of Grid3D. Setting the base values. 
        ! ALWAYS has to be called first before using Grid3D.
        ! Body======================================================================

        self%state_xyz = state_xyz
        self%grid_xyz_dims = grid_xyz_dims!*subgrid_factors  ! Just Remove subgrid factors?
        self%overhead_factor = overhead_factor

        ! Calculate complete_grid_xyz_dims--------------------------------------
        self%complete_grid_xyz_dims = [grid_xyz_dims(1), &                                    
                                       grid_xyz_dims(2), &
                                       grid_xyz_dims(3)] ! Here I need to multiply the subgrid_factors correctly.

        ! Now we multiply the last two dimensions of the grid with 
        ! the dimensions of the tasks in said direction
        self%complete_grid_xyz_dims(state_xyz(2)) = self%complete_grid_xyz_dims(state_xyz(2))*MPI_Cart_Dims(2)  ! Is this correct, 
                                                                                                                ! why 2, 2 | 3, 1?
        self%complete_grid_xyz_dims(state_xyz(3)) = self%complete_grid_xyz_dims(state_xyz(3))*MPI_Cart_Dims(1)

        self%free_space = max( &
                    prod(self%grid_xyz_dims(1:2)), &
                    prod(self%grid_xyz_dims(2:3)), &
                    prod(self%grid_xyz_dims(1:3:2)), &
                    self%complete_grid_xyz_dims(1)*self%overhead_factor, &
                    self%complete_grid_xyz_dims(2)*self%overhead_factor, &
                    self%complete_grid_xyz_dims(3)*self%overhead_factor)

        ! Calculate Free Space-------------------------------------------------
        self%total_space = self%free_space+prod(self%grid_xyz_dims)

    end function createGrid3D

    function get_dims(self) result(dims)
        class(Grid3D)        :: self
        integer, dimension(3):: dims

        dims(1) = self%grid_xyz_dims(self%state_xyz(1))
        dims(2) = self%grid_xyz_dims(self%state_xyz(2))
        dims(3) = self%grid_xyz_dims(self%state_xyz(3))

    end function get_dims

    subroutine perturb_state(self, state_xyz, grid_xyz_dims, &
                             subgrid_factors_xyz, subgrid_dividers_xyz, &
                             perturbation_xyz) 
        ! Parameters================================================================
        class(Grid3D), intent(inout):: self
        integer, intent(in), &
             dimension(3)           :: state_xyz, grid_xyz_dims, &
                                       perturbation_xyz, subgrid_factors_xyz, &
                                       subgrid_dividers_xyz
        ! Loop variables
        integer                     :: i
        ! Notes=====================================================================
        ! As the dimensions should always change with the same factors, the amount 
        !   of free space stays the same. This is why whe only have to change the 
        !   state_xyz and the grid_xyz_dims and not the 1D_pointers.
        ! It is assumed that the Grid3D is already initialized, 
        !   before this function is called!
        ! The Factors are applied first, then the state is perturbed!
        ! When calling this subroutine it is assumed that the data in 
        !   self%allocated_space can be disregarded and overwritten.
        ! Body======================================================================

        ! Perturbation of xyz-axes:
        do i = 1, 3
            self%state_xyz(i) = state_xyz(perturbation_xyz(i))
        end do

        ! Resizing of the xyz-axes:
        self%grid_xyz_dims(state_xyz(1)) = &
            grid_xyz_dims(state_xyz(1))*subgrid_factors_xyz(1)/subgrid_dividers_xyz(1)

        self%grid_xyz_dims(state_xyz(2)) = &
            grid_xyz_dims(state_xyz(2))*subgrid_factors_xyz(2)/subgrid_dividers_xyz(2)

        self%grid_xyz_dims(state_xyz(3)) = &
            grid_xyz_dims(state_xyz(3))*subgrid_factors_xyz(3)/subgrid_dividers_xyz(3)

    end subroutine perturb_state

    !subroutine allocate_array(self, grid_array_gpu)
    !    ! Parameters================================================================
    !        class(Grid3D),   intent(inout)  :: self
    !        integer                         :: total_space
    !        real(kind = wp), intent(inout), &
    !                         allocatable,   &
    !                         device,  &
    !                         dimension(:),  &
    !                         target         :: grid_array_gpu
    !        ! Error handling
    !        integer                         :: ierr
    !    ! Notes=====================================================================
    !    ! The array can be allocated outside this subroutine. The pointer can be
    !    !   set with an existing array, provided it has the right size.
    !    ! Body======================================================================


    !    ! Allocate the grid_array with length prod(grid_xyz_dims)
    !    allocate(grid_array_gpu(self%total_space), stat = ierr)
    !    if (ierr /= 0) error stop "subgrid grid_array: Allocation request denied"

    !    call self%set_pointer_1D(grid_array_gpu)

    !end subroutine allocate_array



    !subroutine print_state_cpu(self, state_string)
    !    ! Parameters================================================================
    !    class(Grid3D), intent(in)   :: self
    !    character(len = 3), optional:: state_string
    !    integer, dimension(3)       :: dims
    !    real(kind = wp), pointer, &
    !                     managed, &
    !                     dimension(:,:,:):: grid3D_pointer_gpu 
    !    real(kind = wp), pointer, &
    !                     dimension(:,:,:):: grid3D_pointer_cpu 
    !    ! Formating:
    !    character(len = 100):: fmt
    !    ! Notes=====================================================================
    !    ! Subroutine to print the sides of the subgrid cube.
    !    ! Body======================================================================

    !    dims = self%get_dims()
    !    call self%get_pointer_3D(grid3D_pointer_gpu, grid3D_pointer_cpu)

    !    state_string(dims(1):dims(1)) = "x"
    !    state_string(dims(2):dims(2)) = "y"
    !    state_string(dims(3):dims(3)) = "z"

    !    write(*,*) "State: ", state_string

    !    write(*,*) "Dims (1, :,:)"
    !    write(fmt, '(A, I0, A)') '(', dims(2), 'F4.0)'
    !    write(*,fmt) grid3D_pointer_cpu(1, :,:)

    !    write(*,*) "Dims (:,1, :)"
    !    write(fmt, '(A, I0, A)') '(', dims(1), 'F4.0)'
    !    write(*,fmt) grid3D_pointer_cpu(:, 1, :)

    !    write(*,*) "Dims (:,:,1)"
    !    write(fmt, '(A, I0, A)') '(', dims(1), 'F4.0)'
    !    write(*,fmt) grid3D_pointer_cpu(:, :, 1)

    !end subroutine print_state_cpu

    subroutine init_comm_requests(self, comm_steps)
        ! NOT DONE, NEEDS TO BE FINNISHED
        class(Grid3D) :: self
        integer       :: comm_steps, ierr

        self%comm_steps = comm_steps
        ierr = 0

        ! waitall should be called before init_comm_request, so this should
        ! throw an error if it is already allocated
        if (allocated(self%GRID_COMM_STATUS)) deallocate(self%GRID_COMM_STATUS, stat = ierr)
        if (ierr /= 0) print *, "ierr: Deallocation request denied self%GRID_COMM_STATUS"

        if (allocated(self%GRID_COMM_REQUESTS)) deallocate(self%GRID_COMM_REQUESTS, stat = ierr)
        if (ierr /= 0) print *, "ierr: Deallocation request denied self%GRID_COMM_STATUS"

        allocate(self%GRID_COMM_STATUS(comm_steps), stat = ierr)
        if (ierr /= 0) print *, "ierr(dim(3)): Allocation request denied"

        allocate(self%GRID_COMM_REQUESTS(comm_steps), stat = ierr)
        if (ierr /= 0) print *, "ierr(dim(3)): Allocation request denied"

    end subroutine init_comm_requests

    subroutine grid_waitall(self)
        class(Grid3D) :: self
        integer       :: ierr

        call MPI_WaitAll(self%comm_steps, self%GRID_COMM_REQUESTS, self%GRID_COMM_STATUS, ierr)
        if (ierr /= MPI_SUCCESS) error stop "Grid_Waitall Failed"

    end subroutine grid_waitall

     !Private Subourtines and Functions ========================================
     !==========================================================================

    pure function prod(arr)
        ! Parameters================================================================
        integer, dimension(:), intent(in):: arr
        integer:: prod
        integer:: i
        ! Notes=====================================================================
        ! Body======================================================================

        prod = 1  ! Initialize product

        do i = 1, size(arr)
            prod = prod*arr(i)
        end do
    end function prod

end module grid_handler 

