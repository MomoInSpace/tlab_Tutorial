! This code demonstrates strategies hiding data transfers via
! asynchronous data copies in multiple streams

module kernels_m
    contains 

    attributes(global) subroutine kernel(a,offset)
        implicit none

    ! Params===================================================================
    real           :: a(*)
    integer, value :: offset
    integer        :: i
    real           :: c, s, x

    ! Body ====================================================================
    i = threadIdx%x + (blockIdx%x-1)*blockDim%x
    x = i; s = sin(x); c = cos(x)
    a(i) = a(i) + sqrt(s**2+c**2)

    end subroutine kernel
end module kernels_m

program testAsync
    use cudafor
    use kernels_m
    implicit none

    ! Params===================================================================
    integer, parameter             :: blockSize = 256, &
                                      nStreams  = 4, &
                                      n = 2**10*1024*blockSize*nStreams 
    real, pinned, allocatable      :: a(:)
    real, device                   :: a_d(n)
    real, managed                  :: a_m(n)
    integer(kind=cuda_stream_kind) :: stream(nStreams)
    type(cudaEvent)                :: startEvent, stopEvent, dummyEvent
    real                           :: time
    integer                        :: i, istat, offset, &
                                      streamSize = n/nStreams
    logical                        :: pinnedFlag
    type(cudaDeviceProp)           :: prop

    ! Body ====================================================================
    istat = cudaGetDeviceProperties(prop, 0)
    write(*,"(' Device: ', a,/)") trim(prop%name)

    ! allocate pinned host memory! --------------------------------------------
    allocate(a(n), STAT=istat, PINNED=pinnedFlag)
    ! Error Handling of Allocation:
    if(istat /= 0) then; write(*,*) 'Allocation of "a" failed'; stop
    else if(.not. pinnedFlag) then; write(*,*) 'Pinned allocation failed'
    end if

    ! create events and streams -----------------------------------------------
    istat = cudaEventCreate(startEvent)
    istat = cudaEventCreate(stopEvent)
    istat = cudaEventCreate(dummyEvent)

    do i = 1, nStreams
        istat = cudaStreamCreate(stream(i))
    end do 

    ! baseline case - sequential transfer and execute -------------------------
    a = 0

    ! time the transfer and the kernel calc 
    istat = cudaEventRecord(startEvent,0)
    a_d = a
    call kernel<<<n/blockSize, blockSize>>>(a_d, 0)
    a   = a_d
    istat = cudaEventRecord(stopEvent, 0)

    ! Calc time difference
    istat = cudaEventSynchronize(stopEvent)
    istat = cudaEventElapsedTime(time, startEvent, stopEvent)

    ! Output the Result
    write(*,*) 'Time for sequential \n', &
               '        transfer and execute (ms): ', time
    write(*,*) '        max error; ', maxval(abs(a-1.0))

    ! Managed memory and execute --------------------------------------------- 
    a_m = 0

    ! time the transfer and the kernel calc 
    istat = cudaEventRecord(startEvent,0)
    call kernel<<<n/blockSize, blockSize>>>(a_m, 0)
    istat = cudaEventRecord(stopEvent, 0)

    ! Calc time difference
    istat = cudaEventSynchronize(stopEvent)
    istat = cudaEventElapsedTime(time, startEvent, stopEvent)

    ! Output the Result
    write(*,*) 'Time for managed \n', &
               '        transfer and execute (ms): ', time
    write(*,*) '        max error; ', maxval(abs(a_m-1.0))

    ! asynchronous version 0.5: loop over {kernel, copy} ----------------------
    a_d = 0

    ! time the transfer and the kernel calc 
    istat = cudaEventRecord(startEvent,0)
    do i = 1, nStreams
        offset = (i-1)*streamSize
        ! istat  = cudaMemcpyAsync(a_d(offset+1), &
        !                          a(offset+1),   & 
        !                          streamSize,     &
        !                          stream(i))

        call kernel<<<streamSize/blockSize, blockSize, 0, stream(i) &
                   >>>(a_d(offset+1:i*streamSize),0)

        istat  = cudaMemcpyAsync(a(offset+1:i*streamSize),   &
                                 a_d(offset+1:i*streamSize), &
                                 streamSize,     &
                                 stream(i))
    end do
    istat = cudaEventRecord(stopEvent, 0)

    ! Calc time difference
    istat = cudaEventSynchronize(stopEvent)
    istat = cudaEventElapsedTime(time, startEvent, stopEvent)

    ! Output the Result
    write(*,*) 'Time for asynchronous (recieve) '
    write(*,*) '        transfer and execute (ms): ', time
    write(*,*) '        max error; ', maxval(abs(a-1.0))


    ! open acc -------------------------
    a = 0

    ! time the transfer and the kernel calc 
    istat = cudaEventRecord(startEvent,0)
    a_d = a

    !$acc kernels deviceptr(a_d)
    do i=1,n
        a_d(i) = a_d(i) + 1
    end do
    !$acc end kernels

    a   = a_d
    istat = cudaEventRecord(stopEvent, 0)

    ! Calc time difference
    istat = cudaEventSynchronize(stopEvent)
    istat = cudaEventElapsedTime(time, startEvent, stopEvent)

    ! Output the Result
    write(*,*) 'Time for open acc \n', &
               '        transfer and execute (ms): ', time
    write(*,*) '        max error; ', maxval(abs(a-1.0))

    ! no gpu -------------------------
    a = 0

    ! time the transfer and the kernel calc 
    istat = cudaEventRecord(startEvent,0)
    !a_d = a

    do i=1,n
        a(i) = a(i) + 1
    end do

    !a   = a_d
    istat = cudaEventRecord(stopEvent, 0)

    ! Calc time difference
    istat = cudaEventSynchronize(stopEvent)
    istat = cudaEventElapsedTime(time, startEvent, stopEvent)

    ! Output the Result
    write(*,*) 'Time for no gpu \n', &
               '        transfer and execute (ms): ', time
    write(*,*) '        max error; ', maxval(abs(a-1.0))

    ! Managed acc memory and execute --------------------------------------------- 
    a_m = 0

    ! time the transfer and the kernel calc 
    istat = cudaEventRecord(startEvent,0)
    !$acc kernels deviceptr(a_m)
    do i=1,n
        a_m(i) = a_m(i) + 1
    end do
    !$acc end kernels
    istat = cudaEventRecord(stopEvent, 0)

    ! Calc time difference
    istat = cudaEventSynchronize(stopEvent)
    istat = cudaEventElapsedTime(time, startEvent, stopEvent)

    ! Output the Result
    write(*,*) 'Time for managed acc \n', &
               '        transfer and execute (ms): ', time
    write(*,*) '        max error; ', maxval(abs(a_m-1.0))

    ! cleanup -----------------------------------------------------------------
    istat = cudaEventDestroy(startEvent)
    istat = cudaEventDestroy(stopEvent)
    istat = cudaEventDestroy(dummyEvent)
    
    do i = 1, nStreams
        istat = cudaStreamDestroy(stream(i))
    end do 

    deallocate(a)
    
end program testAsync
